<!DOCTYPE html>
<html>
<title>CamChat via WebRTC Media Stream Test Page</title>

<head>
    <style id="compiled-css" type="text/css">
        .crop {
            overflow: hidden;
            display: block;
            height: 360px;
        }

        #video {
            margin-left: -15px;
        }

        .display-flex {
            display: flex;
            flex-wrap: wrap;
            text-align: center;
        }

        .display-item {
            margin: 5px;
            width: 300px;
        }

        .button {
            background-color: #d84a38;
            border: none;
            border-radius: 2px;
            color: white;
            font-family: 'Roboto', sans-serif;
            font-size: 0.8em;
            margin: 0 0 1em 0;
            padding: 0.5em 0.7em 0.6em 0.7em;
        }
    </style>
</head>

<script type="module">
    import WaveSurfer from 'https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.esm.js'
    const wavesurfer = WaveSurfer.create({
        container: document.body,
        waveColor: 'rgb(200, 0, 200)',
        progressColor: 'rgb(100, 0, 100)',
        url: 'https://wavesurfer-js.org/examples/audio/audio.wav',
    })
    wavesurfer.once('interaction', () => {
        wavesurfer.play()
    })
</script>

<script src="jquery.min.js"></script>
<script src="sdp_serializer.js"></script>
<script src="adapter-latest.js"></script>
<script src="imagefilter.js"></script>
<script src="flvjs/flv.js"></script>
<!--<script src="socket.io.js"></script>-->
<script src="third_party/graph.js"></script>
<script>
    const autoConstraints = {
        width: 720, height: 540
    };

    const qvgaConstraints = {
        width: {exact: 320}, height: {exact: 240}
    };

    const vgaConstraints = {
        width: {exact: 640}, height: {exact: 480}
    };

    const hdConstraints = {
        width: {exact: 1280}, height: {exact: 720}
    };

    const fullHdConstraints = {
        width: {exact: 1920}, height: {exact: 1080}
    };

    const fourKConstraints = {
        width: {exact: 4096}, height: {exact: 2160}
    };

    const eightKConstraints = {
        width: {exact: 7680}, height: {exact: 4320}
    };

    let videoConstraints = autoConstraints;

    let videoArray = ["video/2.mp4", "video/2.mp4", "video/2.mp4"];
    let videoArrayIndex = 0;

    let loginedUser;
    let client;
    let reqId = 0;
    let callAlready = false;
    let rtc;
    let callType;

    let img;
    let canvasStream;
    let imageFilter;
    let pushVideo = false;
    let pushCanvas = false;
    let imageFilterTimeoutId;

    let lastResult;
    let bitrateSeries = new TimelineDataSeries();
    let bitrateGraph;

    let packetSeries = new TimelineDataSeries();
    let packetGraph;

    let nackSeries = new TimelineDataSeries();
    let nackGraph;

    function reset() {
        reqId = 0;
        callAlready = false;

        $("[id=status]").html('Not Connected');
        $("[id=socketId]").html('');
        $("[id=msgRecv]").html('');
        $("[id=jsonRecv]").html('');
        $("[id=jsonSend]").html('');

        $("[id=localSdpTextarea]").html('');
        $("[id=remoteSdpTextarea]").html('');

        $("[id=errMsg]").attr("style", 'display: none');
        $("[id=errMsgLabel]").html('');
    }

    function handleLogin(obj) {
        let result = (obj.errno == '0')
        if (result) {
            $("[id=pushBtn]").removeAttr("disabled");
            $("[id=pushVideoBtn]").removeAttr("disabled");
            $("[id=pushImageBtn]").removeAttr("disabled");
            $("[id=hangupBtn]").removeAttr("disabled");
            let user = $("[id=user]").val();
            start = user.indexOf('userId=');
            end = user.indexOf('&', start);
            loginedUser = user.substring(start + 'userId='.length, end);
            $("[id=loginedUserLabel]").html('[Current logined user:' + loginedUser + ']');
            heartBeat();
        } else {
            console.log('Global::handleLogin(), login fail: ', obj.errmsg);
        }
    }

    function handleGetIceToken(iceServers) {
        /**
         * Safari
         * 1) when use TCP/TURN, it will abandon some rtp packet if network is unstable. So we just use UDP/TURN here when push
         *
         * Edge does not like
         * 1) stun: filtered after 14393 unless ?transport=udp is present
         * 2) turn: that does not have all of turn:host:port?transport=udp
         * 3) turn: with ipv6 addresses
         * 4) turn: occurring muliple times
         * @type {{iceTransportPolicy: string, iceCandidatePoolSize: number, iceServers: any}}
         */
        let tcpForce = $("[id=forceTcpCb]").attr('checked');
        if (tcpForce) {
            for (i = 0; i < iceServers.length; i++) {
                let obj = iceServers[i];
                for (j = 0; j < obj.urls.length; j++) {
                    let index = obj.urls[j].indexOf("udp", 0);
                    if (index != -1) {
                        obj.urls.splice(j, 1);
                        break;
                    }
                }
            }
        }
        // if (isEdge() || (isSafari() && callType == 'push')) {
        //     for (i = 0; i < iceServers.length; i++) {
        //         let obj = iceServers[i];
        //         for (j = 0; j < obj.urls.length; j++) {
        //             let index = obj.urls[j].indexOf("tcp", 0);
        //             if (index != -1) {
        //                 obj.urls.splice(j, 1);
        //                 break;
        //             }
        //         }
        //     }
        // } else {
        //     for (i = 0; i < iceServers.length; i++) {
        //         let obj = iceServers[i];
        //         for (j = 0; j < obj.urls.length; j++) {
        //             let index = obj.urls[j].indexOf("udp", 0);
        //             if (index != -1) {
        //                 obj.urls.splice(j, 1);
        //                 break;
        //             }
        //         }
        //     }
        // }

        let config = {
            iceServers: iceServers, //[{"urls":["turn:192.168.88.133"],"username":username,"credential":password}],
            iceTransportPolicy: "relay",
            iceCandidatePoolSize: 0,
        };

        if (isEdge() || isFirefox()) {
            config.iceTransportPolicy = "all";
        }

        console.log('Global::handleGetIceToken(), config:', config);
        rtc.config = config;
        const videoSource = $("[id=videoSelector]").val();
        const audioSource = $("[id=audioSelector]").val();

        if (callType == 'push') {
            rtc.push(videoSource, audioSource).then(() => {
                // Set local display
                $("[id=localSdpTextarea]").html(rtc.pc.localDescription.sdp);
                rtc.stat();
            }).catch((e) => {
                console.log("Global::handleGetIceToken(), [Push Fail], e: ", e);
            });

        } else if (callType == 'pull') {
            rtc.pull().then(() => {
                // Start stat
                rtc.stat();
                // Waiting for ICE complete and call sendSdpPull

            }).catch((e) => {
                console.log("Global::handleGetIceToken(), [Pull Fail], e: ", e);
            })
        }
    }

    async function connect() {
        return new Promise((resolve, reject) => {
            let host = '';
            host = $("[id=wss_url]").val();
            client = new WebSocket(host);
            client.binaryType = 'arraybuffer';

            client.onopen = function () {
                console.log('Client.onopen(), host:', host);

                // var bytes = new Uint8Array([0x48, 0x65, 0x6C, 0x6C, 0x6F]); // Hello
                // client.send(bytes.buffer);
                $("[id=status]").html('Connected');

                resolve();
            };

            client.onclose = function (ev) {
                console.log('Client.onclose(), host:', host);

                if (rtc != null) {
                    rtc.hangup();
                }

                $("[id=status]").html('Not Connected');

                $("[id=loginBtn]").removeAttr("disabled");
                $("[id=pushBtn]").attr("disabled", 'true');
                $("[id=hangupBtn]").attr("disabled", 'true');
                $("[id=pushVideoBtn]").attr("disabled", 'true');
                $("[id=pushImageBtn]").attr("disabled", 'true');
            }

            client.onmessage = function (ev) {
                console.log('Client.onmessage(), data:' + ev.data);
                let obj = JSON.parse(ev.data);

                if (obj.route != "imRTC/sendPing") {
                    if (typeof (obj.req_data) != "undefined") {
                        // Recv notice
                        $("[id=jsonRecv]").html(ev.data);
                    } else {
                        // Recv respond
                        $("[id=jsonRespond]").html(ev.data);
                    }
                }

                // if (typeof (obj.errno) == "undefined" || obj.errno == 0) {
                if (obj.route == 'imRTC/sendSdpCallNotice') {
                    $("[id=remoteSdpTextarea]").html(obj.req_data.sdp);
                } else if (obj.route == 'imRTC/sendSdpCall') {
                    if (typeof (obj.data.rtmpUrl) != "undefined") {
                        // demo
                        const rtmpUrl = 'rtmp://' + window.location.hostname + ':8899/play_standard/' + $("#stream").val();
                        let streamAndParams = $("#stream").val();
                        let stream = streamAndParams.substring(0, streamAndParams.indexOf('?'));
                        let params = streamAndParams.substring(streamAndParams.indexOf('?')+1, streamAndParams.length);
                        const flvUrl = window.location.origin + '/flv8889?app=play_standard&stream=' + stream + '&' + params;
                        const hlsUrl = window.location.origin + '/hls/' + stream + '.m3u8';

                        if (rtmpUrl.length > 0) {
                            $("[id=rtmpUrl]").attr("style", 'display: block');
                            $("[id=rtmpUrlLabel]").html(rtmpUrl);
                            $("[id=flvUrlLabel]").html(flvUrl);
                            $("[id=hlsUrlLabel]").html(hlsUrl);

                            const flvHerf = window.location.origin + '/flvjs/demo.html';
                            $("[id=flvUrlHerf]").attr("href", flvHerf);
                            $("[id=hlsUrlHerf]").attr("href", hlsUrl);
                        }
                    }
                } else if (obj.route == 'imRTC/sendSdpAnswerNotice') {
                    $("[id=remoteSdpTextarea]").html(obj.req_data.sdp);
                    $("[id=acceptBtn]").click();
                } else if (obj.route == 'imRTC/sendGetToken') {
                    handleGetIceToken(obj.data.iceServers);
                } else if (obj.route == 'imRTC/login') {
                    handleLogin(obj);
                } else if (obj.route == 'imRTC/sendStartMediaNotice') {
                    $("[id=h264js]").attr("style", 'display: bolck');
                    const h264jsHerf = 'https://' + window.location.hostname + ':9877/camshare_play.html';
                    $("[id=h264jsHerf]").attr("href", h264jsHerf);
                } else {

                }

                if (obj.errmsg.length > 0) {
                    $("[id=errMsg]").attr("style", 'display: block');
                    $("[id=errMsgLabel]").html(obj.errmsg + '(' + obj.errno + ')');
                }

            };
        });
    };

    function send(obj) {
        obj.id = reqId;
        data = JSON.stringify(obj);

        // console.log('Client.send(), ' + data);
        if (client.readyState == client.OPEN) {
            if (obj.route != "imRTC/sendPing") {
                $("[id=jsonSend]").html(data);
            }
            client.send(data);
            reqId++;
            return true;
        } else {
            return false;
        }
    }

    function sendLogin(param) {
        obj = {
            route: 'imRTC/login',
            req_data: {
                param: param
            }
        }

        console.log('Client.sendLogin(),', JSON.stringify(obj));
        send(obj);
    }


    function sendHeartBeat() {
        obj = {
            route: 'imRTC/sendPing',
            req_data: {}
        }
        send(obj);
    }

    function sendSdpCall(stream, sdp) {
        obj = {
            route: 'imRTC/sendSdpCall',
            req_data: {
                stream: stream,
                sdp: sdp,
                ignoreMedia:$("[id=ignoreMediaCb]").attr('checked'),
            }
        }

        // console.log('Client.sendSdpCall(), ', JSON.stringify(obj));
        console.log('Client.sendSdpCall()');
        send(obj);
    }

    function heartBeat() {
        console.log('Client.heartBeat()');
        setTimeout(() => {
            if( client.readyState == client.OPEN ) {
                sendHeartBeat();
                heartBeat();
            }
        }, 60000);
    }

    async function sendGetToken(stream) {
        // await connect();
        let user_id = stream;// + "-" + Math.random().toString(36).substr(2).toLocaleUpperCase();
        obj = {
            route: 'imRTC/sendGetToken',
            req_data: {
                user_id: user_id,
            }
        }

        console.log('Client.sendGetToken(), ', JSON.stringify(obj));
        send(obj);
    }

    async function call(isPull, isLocalVideo, isCanvas) {
        rtc.hangup();

        pushVideo = isLocalVideo;
        pushCanvas = isCanvas;

        if (isPull) {
            callType = 'pull';
        } else {
            callType = 'push';
        }

        sendGetToken(loginedUser);

        $("[id=pushBtn]").attr("disabled", 'true');
        $("[id=pushVideoBtn]").attr("disabled", 'true');
        $("[id=pushImageBtn]").attr("disabled", 'true');
    }

    async function login() {
        if (typeof (client) != "undefined") {
            client.close();
        }

        reset();
        $("[id=loginBtn]").attr("disabled", 'true');
        await connect();
        sendLogin($("[id=user]").val());
    }

    class RTCClient {
        constructor(config) {
            this.mediaStream = null;
            this.pc = null;
            this.config = config;
            this.onicecandidate = null;
            this.onicecomplete = null;
        }

        init() {
            this.pc = new RTCPeerConnection(this.config);
            this.mediaStream = null;

            this.pc.onicecandidate = event => {
                if (!event.candidate) {
                    return;
                }

                let json = JSON.stringify(event.candidate);
                console.log('RTCClient::onicecandidate(), candidate:', json);

                // Get local ICE
                let sdp = this.pc.localDescription.sdp;
                this.onicecandidate(sdp, event.candidate);
            };

            this.pc.ontrack = event => {
                console.log('RTCClient::ontrack(), stream:', event.streams[0]);
                $("[id=localVideo]").attr("style", 'display: block');
                let video = $("[id=localVideo]")[0];
                if ($("[id=localVideo]")[0].srcObject !== event.streams[0]) {
                    $("[id=localVideo]").attr("srcObject", event.streams[0]);
                }
            };

            this.pc.onicegatheringstatechange = event => {
                console.log('RTCClient::onicegatheringstatechange(), iceGatheringState:', this.pc.iceGatheringState);
                if (this.pc.iceGatheringState == 'complete') {
                    this.onicecomplete();
                }
            };

            this.pc.oniceconnectionstatechange = event => {
                console.log('RTCClient::oniceconnectionstatechange(), iceConnectionState:', this.pc.iceConnectionState);
                if (this.pc.iceConnectionState === 'closed') {
                }
            };
        }

        async hangup() {
            this.close();

            $("[id=localSdpTextarea]").attr("disabled", true);
            $("[id=callButton]").attr("disabled", false);
            $("[id=acceptButton]").attr("disabled", false);

            $("[id=stats]").html("");

            localVideo.srcObject = null;
            localVideo.src = "";
        }

        async push(videoSource, audioSource) {
            this.init();
            let muteVideo = $("[id=muteVideoCb]").attr('checked');
            let muteAudio = $("[id=muteAudioCb]").attr('checked');

            if (pushVideo) {
                await this.showStaticVideo(muteVideo, muteAudio).catch(err => {
                    console.log('RTCClient::push(), err :', err);
                });
            } else {
                await this.showLocalVideo(videoSource, audioSource, muteVideo, muteAudio);
            }

            let offer = await this.pc.createOffer({
                offerToReceiveAudio: false,
                offerToReceiveVideo: false
            });
            offer.sdp = this.createLocalSdp(offer.sdp);

            await this.pc.setLocalDescription(offer);

            // let localDescription = JSON.stringify(this.pc.localDescription);
            console.log('RTCClient::push(), pushVideo:', pushVideo);

            $("[id=localSdpTextarea]").html(offer.sdp);
            $("[id=localSdpTextarea]").attr("disabled", false);
            $("[id=acceptButton]").attr("disabled", false);
        }

        async accpet(answer) {
            console.log('RTCClient::accpet(), answer: ', answer);
            $("[id=acceptButton]").attr("disabled", true);
            await this.pc.setRemoteDescription(answer);
        }

        close() {
            if (this.pc != null) {
                this.pc.close();
                this.pc = null;
            }
            this.stopLocalVideo();
            this.mediaStream = null;
        }

        echoStaticVideo(localVideo, muteVideo, muteAudio) {
            var canvas = $("[id=localCanvas]")[0];
            draw();
            let canvasStream = null;

            if (isFirefox()) {
                this.mediaStream = localVideo.mozCaptureStream();
            } else {
                this.mediaStream = localVideo.captureStream();
            }

            console.log('Captured stream from leftVideo with captureStream',
                this.mediaStream);

            let videoTrack = this.mediaStream.getVideoTracks()[0];
            let audioTrack = this.mediaStream.getAudioTracks()[0];
            if (muteVideo) {
                videoTrack.enabled = false;
                // this.mediaStream.removeTrack(audioTrack);
            }
            if (muteAudio) {
                audioTrack.enabled = false;
                // this.mediaStream.removeTrack(audioTrack);
            }

            if (pushCanvas) {
                if (isFirefox()) {
                    canvasStream = canvas.mozCaptureStream();
                } else {
                    canvasStream = canvas.captureStream();
                }
                // let canvasVideoTrack = canvasStream.getVideoTracks()[0];
                // this.mediaStream.removeTrack(videoTrack);
                // this.mediaStream.addTrack(canvasVideoTrack);
                this.mediaStream = canvasStream;
                localVideo.srcObject = canvasStream;
            }

            if (this.pc) {
                this.pc.addStream(this.mediaStream);
            }

            let video = this.mediaStream.getVideoTracks()[0];
            if (!isFirefox() && !isEdge()) {
                let capabilities = video.getCapabilities();
                console.log('# Captured stream capabilities', capabilities);
            }
            let constraints = video.getConstraints();
            // if ( !isFirefox() ) {
            constraints.frameRate = 10;
            constraints.minFrameRate = 8;
            constraints.maxFrameRate = 15;
            try {
                video.applyConstraints(constraints);
            } catch (e) {
                console.log('Captured stream constraints error:', e);
            }
            // }
            console.log('# Captured stream constraints', constraints);
        }

        async showStaticVideo(muteVideo, muteAudio) {
            return new Promise((resolve, reject) => {
                // Video tag capture must be set up after video tracks are enumerated.
                let localVideo = $("[id=localVideo]")[0];
                $("[id=localVideo]").attr("style", 'display: block');
                localVideo.src = './video/test.mp4';
                localVideo.srcObject = null;
                // localVideo.muted = muteAudio;

                localVideo.oncanplay = () => {
                    if (this.mediaStream == null) {
                        this.echoStaticVideo(localVideo, muteVideo, muteAudio);
                        resolve();
                    } else {
                        reject('this.mediaStream != null');
                    }
                };
                if (localVideo.readyState >= 3) {
                    if (this.mediaStream == null) {
                        this.echoStaticVideo(localVideo, muteVideo, muteAudio);
                        resolve();
                    } else {
                        reject('this.mediaStream != null');
                    }
                }
                localVideo.play();
            });
        }

        async showLocalVideo(videoSource, audioSource, muteVideo=false, muteAudio=false) {
            $("[id=localVideo]").attr("style", 'display: block');
            $("[id=localVideo]").attr('src', null);

            /**
             * Edge does not support custom video size
             * only support original video capture size, example: 320x240, 640x480
             */
            let videoDevice = {
                deviceId: videoSource ? {exact: videoSource} : undefined,
            }
            let videoConfig = Object.assign(videoDevice, videoConstraints);

            let audioDevice = {
                deviceId: audioSource ? {exact: audioSource} : undefined,
            }
            let audioConfig = Object.assign(audioDevice);
            let config = {
                video: videoConfig,
                audio: audioConfig
            }

            if (muteVideo) {
                config.video = false;
            }
            if (muteAudio) {
                config.audio = false;
            }

            return window.navigator.mediaDevices.getUserMedia(config).then(mediaStream => {
                this.setVideoTrackContent(mediaStream);
                this.mediaStream = mediaStream;

                let leftVideo = $("[id=localVideo]")[0];
                leftVideo.src = '';
                leftVideo.srcObject = null;
                $("[id=localVideo]").attr('srcObject', mediaStream);

                this.pc.addStream(mediaStream);

                let video = mediaStream.getVideoTracks()[0];
                if (typeof (video) == "undefined" || video == null) {
                    console.log("RTCClient::showLocalVideo(), No Video Can Be Captured.");
                } else {
                    if (!isFirefox() && !isEdge()) {
                        let capabilities = video.getCapabilities();
                        console.log('# Captured stream capabilities', capabilities);
                    }
                    let constraints = video.getConstraints();
                    constraints.frameRate = 10;
                    constraints.minFrameRate = 8;
                    constraints.maxFrameRate = 15;
                    try {
                        video.applyConstraints(constraints);
                    } catch (e) {
                        console.log('Captured stream constraints error:', e);
                    }
                }

                // }
                // (async () => {
                //     // const workerCode = document.querySelector('#workerCode').textContent;
                //     // const blob = new Blob([workerCode], { type: 'text/javascript' });
                //     // const url = URL.createObjectURL(blob);
                //     const url = 'webgl-worker.js';
                //     const worker = new Worker(url, { name : 'webgl'});
                //     const canvas = $("[id=localCanvas]")[0].transferControlToOffscreen();
                //     worker.postMessage({msg:'draw', canvas:canvas}, [canvas]);
                //     URL.revokeObjectURL(url);
                // })();
            }).catch(e => {
                console.log("RTCClient::showLocalVideo(), [Fail], e: ", e);
            });
        }

        async showStaticCanvas() {
            return new Promise((resolve, reject) => {
                // Video tag capture must be set up after video tracks are enumerated.
                var canvas = $("[id=localCanvas]")[0];
                draw();

                $("[id=localVideo]").attr("style", 'display: block');
                let leftVideo = $("[id=localVideo]")[0];
                leftVideo.src = '';
                leftVideo.srcObject = null;

                if (this.mediaStream == null) {
                    if (isFirefox()) {
                        this.mediaStream = canvas.mozCaptureStream();
                    } else {
                        this.mediaStream = canvas.captureStream();
                    }
                    leftVideo.srcObject = this.mediaStream;
                    this.pc.addStream(this.mediaStream);
                }
                resolve();
            });
        }

        async stopLocalVideo() {
            $("[id=localVideo]").attr("style", 'display: none');
            if (this.mediaStream) {
                this.mediaStream.getTracks().forEach(
                    track => track.stop()
                );
                $("[id=localVideo]").attr('srcObject', null);
                $("[id=localVideo]").attr('src', null);
            }
        }

        setBandwidth(bandwidth) {
            // In Chrome, use RTCRtpSender.setParameters to change bandwidth without
            // (local) renegotiation. Note that this will be within the envelope of
            // the initial maximum bandwidth negotiated via SDP.
            if (
                (adapter.browserDetails.browser === 'firefox' &&
                    adapter.browserDetails.version >= 64) &&
                'RTCRtpSender' in window &&
                'setParameters' in window.RTCRtpSender.prototype) {
                const sender = this.pc.getSenders()[0];
                const parameters = sender.getParameters();
                if (!parameters.encodings) {
                    parameters.encodings = [{}];
                }
                parameters.encodings[0].maxFramerate = 15;
                if (bandwidth === 'unlimited') {
                    delete parameters.encodings[0].maxBitrate;
                } else {
                    parameters.encodings[0].maxBitrate = bandwidth * 1000;
                }
                sender.setParameters(parameters)
                    .then(() => {
                    })
                    .catch(e => console.error(e));
            }
        }

        createLocalSdp(sdp) {
            var newSdp = sdp;
            newSdp = this.setBitRate(sdp);
            // newSdp = newSdp.replace(/m=video (\d+) UDP\/TLS\/RTP\/SAVPF ([0-9 ]*)/g, 'm=video $1 UDP/TLS/RTP/SAVPF 102');
            // newSdp = newSdp.replace(/m=audio (\d+) UDP\/TLS\/RTP\/SAVPF ([0-9 ]*)/g, 'm=audio $1 UDP/TLS/RTP/SAVPF 111');
            // newSdp = newSdp.replace(/a=rtcp-fb:(?!102)(?!111)\d{1,3} .*\r\n/g, '');
            // newSdp = newSdp.replace(/a=fmtp:((?!102)(?!111))\d{1,3} .*\r\n/g, '');
            // newSdp = newSdp.replace(/a=rtpmap:(?!102)(?!111)\d{1,3} .*\r\n/g, '');

            // newSdp = newSdp.replace(/a=rtcp-fb:(?!111)\d{1,3} .*\r\n/g, '');
            // newSdp = newSdp.replace(/a=fmtp:(?!111)\d{1,3} .*\r\n/g, '');
            // newSdp = newSdp.replace(/a=rtpmap:(?!111)\d{1,3} .*\r\n/g, '');

            // newSdp = newSdp.replace(/a=extmap:.*\r\n/g, '');
            // newSdp = newSdp.replace(/a=msid.*\r\n/g, '');
            // newSdp = newSdp.replace(/a=rtcp:.*\r\n/g, '');
            return newSdp;
        }

        setBitRate(sdp) {
            var newSdp = sdp;
            // Only work for Safari and Chrome
            newSdp = newSdp.replace(/a=fmtp:(.*)\r\n/g, 'a=fmtp:$1;x-google-start-bitrate=500;x-google-min-bitrate=200;x-google-max-bitrate=600\r\n');
            // newSdp = newSdp.replace(/a=fmtp:(.*)\r\n/g, 'a=fmtp:$1;x-google-start-bitrate=600;x-google-min-bitrate=200\r\n');
            // Only work for Firefox
            // newSdp = newSdp.replace(/a=mid:(.*)\n/g, 'a=mid:$1\r\nb=TIAS:1000000\r\n');
            this.setBandwidth(600);
            return newSdp;
        }

        /**
         * / Only work for Chrome
         * @param stream
         * @param hint
         */
        setVideoTrackContent(stream, hint) {
            const tracks = stream.getVideoTracks();
            tracks.forEach(track => {
                // Get old constraints
                let constraints = track.getConstraints();
                if ('contentHint' in track) {
                    track.contentHint = 'motion';
                } else {
                    console.log('RTCClient::setVideoTrackContent(), MediaStreamTrack contentHint attribute not supported');
                }
                // constraints.width = {exact:480};
                // constraints.height = {exact:360};
                // It is always success, unless you set some parameter with exact value
                track.applyConstraints(constraints).then(() => {
                    console.log('RTCClient::setVideoTrackContent(), [OK], constraints:', constraints);
                }, e => {
                    console.log('RTCClient::setVideoTrackContent(), [Fail], e:', e);
                });

                // if ('contentHint' in track) {
                //     track.contentHint = hint;
                //     if (track.contentHint !== hint) {
                //         console.log('RTCClient::createStream( Invalid video track contentHint: ' + hint + ' )');
                //     }
                // } else {
                //     console.log('RTCClient::createStream( contentHint attribute not supported )');
                // }
            });
        }

        stat() {
            setTimeout(() => {
                if (this.pc != null) {
                    this.pc.getStats(null).then(
                        results => {
                            let statsString = "";
                            results.forEach(res => {
                                // console.log("RTCClient::stat( " + res.type + " )");
                                if (res.type != 'codec' && res.type != 'certificate') {
                                    statsString += '<h3>Report type=';
                                    statsString += res.type;
                                    statsString += '</h3>\n';

                                    Object.keys(res).forEach(k => {
                                        statsString += `${k}: ${res[k]}<br>`;
                                    });
                                }

                                if (res.type === 'outbound-rtp') {
                                    const now = res.timestamp;
                                    let bytes = res.bytesSent;
                                    let packets = res.packetsSent;
                                    let nacks = res.nackCount;
                                    if (lastResult && lastResult.has(res.id)) {
                                        // calculate bitrate and append to chart
                                        const bitrate = 8 * (bytes - lastResult.get(res.id).bytesSent) /
                                            (now - lastResult.get(res.id).timestamp);
                                        bitrateSeries.addPoint(now, bitrate);
                                        bitrateGraph.setDataSeries([bitrateSeries]);
                                        bitrateGraph.updateEndDate();

                                        // calculate number of packets and append to chart
                                        const packetSecond =  packets - lastResult.get(res.id).packetsSent;
                                        packetSeries.addPoint(now, packetSecond);
                                        packetGraph.setDataSeries([packetSeries]);
                                        packetGraph.updateEndDate();

                                        // calculate number of nack rtcp packets received and append to chart
                                        const nackSecond = nacks - lastResult.get(res.id).nackCount;
                                        nackSeries.addPoint(now, nackSecond);
                                        nackGraph.setDataSeries([nackSeries]);
                                        nackGraph.updateEndDate();
                                    }
                                }
                            });
                            $("[id=stats]").html(statsString);
                            lastResult = results;
                        }
                    );

                    this.stat();
                } else {
                    $("[id=stats]").html("");
                }
            }, 1000);
        }

    }

    function showUserAgent() {
        var userAgent = navigator.userAgent;
        $("[id=userAgent]").html(userAgent);
    }

    function isIE() {
        return navigator.userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1;
    }

    function isEdge() {
        // return navigator.userAgent.indexOf("Edge") > -1 && !isIE();
        return (adapter.browserDetails.browser == 'edge');
    }

    function isSafari() {
        return (adapter.browserDetails.browser == 'safari');
    }

    function isFirefox() {
        return (adapter.browserDetails.browser == 'firefox');
    }

    // function draw() {
    //     var video = $("[id=localVideo]")[0];
    //     imageFilter.drawImage(video);
    //     imageFilter.draw();
    //     setTimeout(() => {
    //         draw();
    //     }, 100);
    // }

    function draw(img) {
        if (img) {
            imageFilter.drawImage(img);
        }
        imageFilter.draw();
        return setTimeout(() => {
            draw();
        }, 50);
    }

    function onload() {
        if (!window.navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            alert('WebRTC.mediaDevices is not supported.');
            return;
        }

        if (!window.RTCPeerConnection) {
            alert('WebRTC.RTCPeerConnection is not supported.');
            return;
        }

        console.log("Browser is " + adapter.browserDetails.browser);

        rtc = new RTCClient();
        rtc.onicecandidate = () => {
            $("[id=localSdpTextarea]").html(rtc.pc.localDescription.sdp);
            if (callType == 'push' || callType == 'pull') {
                if (callAlready) {
                    // Update sdp to media server
                    // let json = JSON.stringify(event.candidate);
                    // console.log("Rtc onicecandidate, candidate: ", json);
                    // sendSdpUpdate($("[id=stream]").val(), rtc.pc.localDescription.sdp);
                }
            }
        };

        rtc.onicecomplete = () => {
            // Get Whole sdp with ice candidate, but it maybe cost time
            $("[id=localSdpTextarea]").html(rtc.pc.localDescription.sdp);
            // Send sdp call to media server
            if (callType == 'push') {
                sendSdpCall($("#stream").val(), $("#localSdpTextarea").val());
            } else if (callType == 'pull') {
                sendSdpPull($("#stream").val(), $("#localSdpTextarea").val(), $("#serverId").val());
            }
        }

        $("[id=loginBtn]").click(function () {
            login();
        });

        $("[id=pushBtn]").click(function () {
            call(false, false);
        });
        $("[id=pushBtn]").attr("disabled", 'true');

        $("[id=acceptBtn]").click(function accept() {
            let remoteSdp = remoteSdpTextarea.value;
            let answer = {
                type: 'answer',
                sdp: remoteSdp
            }
            rtc.accpet(answer).then(function success() {
                console.log("Rtc Accept, [OK]");
            }, e => {
                console.log("Rtc Accept, [Fail], e: ", e);
            })
        });

        $("[id=hangupBtn]").click(function () {
            if (typeof (client) != "undefined") {
                client.close();
            }
            rtc.hangup();
        });
        $("[id=hangupBtn]").attr("disabled", 'true');

        $("[id=pushVideoBtn]").click(function () {
            call(false, true);
        });
        $("[id=pushVideoBtn]").attr("disabled", 'true');
        if (isEdge()) {
            $("[id=pushVideoBtn]").attr("style", 'display:none');
        }
        $("[id=pushImageBtn]").click(function () {
            let img = $("[id=localImg]")[0];
            clearTimeout(imageFilterTimeoutId);
            imageFilterTimeoutId = draw(img);

            call(false, true, true);
        });
        $("[id=pushImageBtn]").attr("disabled", 'true');


        $("[id=pullBtn]").click(function () {
            $("[id=pullHangupBtn]").removeAttr("disabled");
            let streamAndParams = $("#pullStream").val();
            const flvUrl = window.location.origin + '/flv8889?' + streamAndParams;
            flv_load(flvUrl);
        });
        $("[id=pullHangupBtn]").attr("disabled", 'true');
        $("[id=pullHangupBtn]").click(function () {
            flv_destroy();
            $("[id=flvjsVideo]").attr("style", 'display: none');
            $("[id=pullHangupBtn]").attr("disabled", 'true');
        });

        // Choose video constraints
        getVideoWithConstraints(autoConstraints, 'AUTO');
        $("[id=autoBtn]").click(function () {
            getVideoWithConstraints(autoConstraints, 'AUTO');
        });
        $("[id=qvgaBtn]").click(function () {
            getVideoWithConstraints(qvgaConstraints, 'QVGA');
        });
        $("[id=vgaBtn]").click(function () {
            getVideoWithConstraints(vgaConstraints, 'VGA');
        });
        $("[id=hdBtn]").click(function () {
            getVideoWithConstraints(hdConstraints, 'HD');
        });
        $("[id=fullHdBtn]").click(function () {
            getVideoWithConstraints(fullHdConstraints, 'FullHD');
        });

        bitrateGraph = new TimelineGraphView('bitrateGraph', 'bitrateCanvas');
        bitrateGraph.updateEndDate();

        packetGraph = new TimelineGraphView('packetGraph', 'packetCanvas');
        packetGraph.updateEndDate();

        nackGraph = new TimelineGraphView('nackGraph', 'nackCanvas');
        nackGraph.updateEndDate();

        let canvas = $("[id=localCanvas]")[0];
        imageFilter = new ImageFilter();
        imageFilter.init(canvas);

        let img = $("[id=localImg]")[0];
        img.onload = function () {
        }

        let host = '';
        if (window.location.protocol == 'https:') {
            host = 'wss://' + window.location.hostname + ':9083';
        }
        $("[id=wss_url]").val(host);
    }

    function handleError(e) {
        console.log('navigator.MediaDevices.getUserMedia, [Fail], e:', e);
    }

    function gotDevices(deviceInfos) {
        // Handles being called several times to update labels. Preserve values.
        let defaultVideo;
        let defaultAudio;
        for (let i = 0; i !== deviceInfos.length; ++i) {
            const deviceInfo = deviceInfos[i];
            // console.log('Got Device: ', deviceInfo);
            if (deviceInfo.kind === 'videoinput') {
                console.log('Got Video Capture Input : ', deviceInfo);
                if (i==0) {
                    defaultVideo = deviceInfo.deviceId;
                    $("[id=videoSelector]").val(defaultVideo);
                }

                $("[id=videoSelector]").append("<option value=" + deviceInfo.deviceId + ">" + "label:" + deviceInfo.label + ", deviceId:" + deviceInfo.deviceId + "</option>");
                let n = deviceInfo.label.search('ManyCam');
                if (n > -1) {
                    defaultVideo = deviceInfo.deviceId;
                    $("[id=videoSelector]").val(defaultVideo);
                }
            } else if (deviceInfo.kind === 'audioinput') {
                console.log('Got Audio Capture Input : ', deviceInfo);
                if (i==0) {
                    defaultAudio = deviceInfo.deviceId;
                    $("[id=audioSelector]").val(defaultAudio);
                }

                $("[id=audioSelector]").append("<option value=" + deviceInfo.deviceId + ">" + "label:" + deviceInfo.label + ", deviceId:" + deviceInfo.deviceId + "</option>");
                let n = deviceInfo.label.search('ManyCam');
                if (n > -1) {
                    defaultAudio = deviceInfo.deviceId;
                    $("[id=audioSelector]").val(defaultAudio);
                }
            }
        }
    }

    function getVideoWithConstraints(constraints, name) {
        let jsonConst = JSON.stringify(constraints);
        $("[id=videoConstLabel]").html('Now is ' + name + ', ' + jsonConst);

        let videoTestConfig = {video: constraints};
        videoConstraints = constraints;
    }

    function flv_load(url) {
        let mediaDataSource = {
            url:url,
            type: 'flv',
            isLive: true,
            hasAudio:1,
            hasVideo:1,
        };

        flv_destroy();
        player = flvjs.createPlayer(mediaDataSource, {
            enableWorker: false,
            lazyLoadMaxDuration: 3 * 60,
            seekType: 'range',
            autoCleanupMaxBackwardDuration: 3,
            autoCleanupMinBackwardDuration: 1,
        });

        let element = $("[id=flvjsVideo]")[0];
        $("[id=flvjsVideo]").attr("style", 'display: block');
        player.attachMediaElement(element);
        player.load();

        player.on(flvjs.Events.MEDIA_INFO, (mediaInfo) => {
            console.log('[FLVPlayer]MEDIA_INFO', mediaInfo);
        });
        player.on(flvjs.Events.METADATA_ARRIVED, (metadata) => {
            console.log('[FLVPlayer]METADATA_ARRIVED', metadata);
        });
        // player.on(flvjs.Events.STATISTICS_INFO, (statInfo) => {
        //     console.log('flvjs.Events.STATISTICS_INFO', statInfo);
        // });
        player.on(flvjs.Events.RECOVERED_EARLY_EOF, () => {
            console.log('[FLVPlayer]RECOVERED_EARLY_EOF');
        });

        player.on(flvjs.Events.ERROR, (err, detail, info) => {
            // 参数 err 是一级异常，errDetail 是二级异常
            if (err == flvjs.ErrorTypes.MEDIA_ERROR) {
                console.log('[FLVPlayer]MEDIA_ERROR', detail, info)
                if(detail == flvjs.ErrorDetails.MEDIA_FORMAT_UNSUPPORTED) {
                }
            } else if (err == flvjs.ErrorTypes.NETWORK_ERROR) {
                console.log('[FLVPlayer]NETWORK_ERROR', detail, info)
                if(detail == flvjs.ErrorDetails.NETWORK_STATUS_CODE_INVALID) {
                }
            } else if (err == flvjs.ErrorTypes.OTHER_ERROR) {
                console.log('[FLVPlayer]OTHER_ERROR', detail, info)
            }
            flv_destroy();

            $("[id=flvjsVideo]").attr("style", 'display: none');
            $("[id=pullHangupBtn]").attr("disabled", 'true');
        });
    }

    function flv_destroy() {
        if (typeof player != "undefined" && player != null) {
            player.pause();
            player.unload();
            player.detachMediaElement();
            player.destroy();
            player = null;
        }
    }

    document.addEventListener("DOMContentLoaded", function () {
        onload();
        showUserAgent();
        navigator.mediaDevices.enumerateDevices().then(gotDevices).catch(handleError);
        var supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
        console.log('SupportedConstraints : ', supportedConstraints);
    });
    // window.onload = onload();

</script>

<body>
<div id="">
    UserAgent :
    <lable id="userAgent"></lable>
    <br>
    Websocket Status :
    <lable id="status">Not Connected</lable>
    <br>
    <p>################################################################</p>
    <div class="video-box">
        <div id="local">
            <div id="errMsg" style="display: none">
                Error Msg :
                <font color="#FF0000">
                    <lable id="errMsgLabel"></lable>
                </font>
            </div>
            <div id="rtmpUrl" style="display: none">
                [rtmp]:
                <lable id="rtmpUrlLabel"></lable>
                <br>
                [flv]:
                <lable id="flvUrlLabel"></lable> <a href="#" id="flvUrlHerf" target="blank"
                                                         name="play">Flvjs播放</a>
                <br>
                [hls]:
                <lable id="hlsUrlLabel"></lable> <a href="#" id="hlsUrlHerf" target="blank"
                                                         name="play">HLS播放</a>
                <br>
                <br>
                <!--HLS Flv Url : <lable id="hlsUrlLabel"></lable>&nbsp;<a href="#" id="hlsUrlHerf" target="blank" name="play">HLS播放</a>-->
                <p>################################################################</p>
            </div>
        </div>

        <div>
            <div>
                # MediaServer: <input id="wss_url" type="text" name="" style="width:480px"
                              value="wss://192.168.88.201:9083"/>
            </div>
            <div>
                # 登录: userId=用户Id&siteId=站点Id <lable id="loginedUserLabel"></lable></br>
                # 参数: <input id="user" type="text" name="" style="width:480px"
                                value="userId=max88&siteId=4&sid=ve712htsm4v3dvb89omeu8sphi&userType=0"/>
                <button id="loginBtn">Login</button>
            </div>
            <div>
                # RTC </br>
                # 推流: [Stream?userId=用户Id&siteId=站点Id, Example: max88?userId=max88&siteId=4</br>
                # 参数: <input id="stream" type="text" name="" style="width:480px"
                               value="max88?userId=max88&siteId=4&mediasecret=AE688FDB49BB"/>
                <button id="pushBtn">Push</button>
                <button id="pushVideoBtn">PushVideo</button>
                <button id="pushImageBtn">PushImage</button>
                <button id="hangupBtn">Hangup</button>
                <button id="acceptBtn" style="display: none;">Accept</button>
            </div>
            <div>
                # HTTP-FLV </br>
                # 拉流: [app=play_standard_应用Id&userId=用户Id&siteId=站点Id, Example: max88?userId=max88&siteId=4</br>
                # 参数: <input id="pullStream" type="text" name="" style="width:480px"
                               value="app=play_standard_1&stream=max88&userId=max88&siteId=4&mediasecret=AE688FDB49BB"/>
                <button id="pullBtn">Pull</button>
                <button id="pullHangupBtn">PullHangup</button>
            </div>
        </div>
    </div>
    <p>### Local Video & Canvas ###</p>
    <p># Local SDP</p>
    <textarea id="localSdpTextarea" disabled="true"></textarea>
    <div>
        Force Tcp <input id="forceTcpCb" type="checkbox" checked="checked">|Ignore Media <input id="ignoreMediaCb" type="checkbox" >
        <div>Mute Video <input id="muteVideoCb" type="checkbox" ></div>
        <div>Mute Audio <input id="muteAudioCb" type="checkbox" ></div>
    </div>
    <div>
        <p>################################################################</p>
    </div>
    <div id="videoConfigDiv">
        <p>############################ Video Config ############################</p>
        <div class="button">
            <button id="autoBtn">AUTO</button>
            <button id="qvgaBtn">QVGA</button>
            <button id="vgaBtn">VGA</button>
            <button id="hdBtn">HD</button>
            <button id="fullHdBtn">FullHD</button>
            <lable id="videoConstLabel"></lable>
        </div>
        <p></p>
        <div>Video:<select id="videoSelector"></select></div>
        <div>Audio:<select id="audioSelector"></select></div>
    </div>
    <p></p>
    <label id="videoDescLabel">############################ Local Video ############################</label>
    <video id="localVideo" width="" height="" autoplay style="display:none" loop="loop" playsinline="true"></video>
    <canvas id="localCanvas" width="640" height="480" style="display:none"></canvas>
    <img id="localImg" src="img/1.jpg" style="display:none"></br>
    <label id="videoRemoteDescLabel">############################ Remote Video ############################</label>
    <video id="remoteVideo" width="" height="" autoplay style="display:none;width=100%;height=100%;object-fit:fill" loop="loop" playsinline="true"></video>
    <video id="flvjsVideo" class="" style="display: none" autoplay="" src="">
        Your browser is too old which doesn't support HTML5 video.
    </video>
</div>
<div class="display-flex">
    <div class="display-item">
        <div><label id="bitrateLabel">Bitrate</label></div>
        <canvas id="bitrateCanvas"></canvas>
    </div>
    <div class="display-item">
        <div><label id="packetLabel">RTP packets sent per second</label></div>
        <canvas id="packetCanvas"></canvas>
    </div>
    <div class="display-item">
        <div><label id="nackLabel">Nack receive per second</label></div>
        <canvas id="nackCanvas"></canvas>
    </div>
</div>
<label id="stats"></label>

<p>### Remote Video ###</p>
<div id="remote">
    <p># Remote SDP #</p>
    <textarea id="remoteSdpTextarea"></textarea>
</div>
</div>

<p>################################################################
<div style="color:#00F000">
    json recv :
    <lable id="jsonRecv"></lable>
</div>
<div style="color:#F00000">
    json request :
    <lable id="jsonSend"></lable>
</div>
<div style="color:#0000F0">
    json respond :
    <lable id="jsonRespond"></lable>
</div>
</body>
</html>
